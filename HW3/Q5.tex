%نام و نام خانوادگی:
%شماره دانشجویی: 
\مسئله{}
 در فرآیند تحلیل و طراحی نرم‌افزار، مفهومی به نام «بی‌درزی \footnote{Seamlessness}» وجود دارد.
\begin{enumerate}[a)]
	\item 
این مفهوم به چه معناست؟
	 \item 
به چه متدولوژی‌ای بی‌درز گفته می‌شود؟
	\item
متدولوژی x یک متدولوژی نیازمندی‌رانه \footnote{Requirements-driven} است. به نظر شما آیا این متدولوژی بی‌درز است؟
	\item
متدولوژی اسکرام را از نظر بی‌درزی بررسی کنید.
\end{enumerate}

\پاسخ{
	
	
	\begin{enumerate}[a)]
		\item 
		مفهوم \lr{Seamlessness} به معنی کیفیت و چگونگی تبدیل طبیعی موضوع مورد بحث از حوزه مسئله به حوزه طراحی سیستم و سپس به کد قابل اجرا است. به بیان دیگر، شباهت‌هایی که بین وظایف مختلفی که در حین فرآیند تولید  نرم افزار و پروژه وجود دارد، عموما بسیار بیش‌تر از تفاوت هاست و در نتیجه آن می‌توانیم به یک پروسه پیوسته و یکپارچه دست یابیم که ارتباط بین عوامل موثر در تولید نرم‌افزار را بهبود بخشیده و در نتیجه آن باعث می‌شود که یک نگاشت مستقیم از حوزه مسئله به حوزه راه‌حل نرم‌افزاری پیدا کنیم. نتیجه نهایی همه این‌ها یک محصول نهایی باکیفیت است.
		
		مفهوم \lr{Seamlessness} با دو مفهوم بازگشت‌پذیری ارتباط بالایی دارد. بازگشت‌پذیری بدین معناست که این پروسه یکپارچه و بی‌درز، باید در هر دو جهت ببقرار باشد. بدین معنی که اگر یک شخص سیستمی که به مرحله پیاده‌سازی رسیده است را تغییر بدهد، باید بتوان این تغییرات را در جهت معکوس انتشار داده و در طرااحی‌های سطح بالا، مشخصات و همچنین تحلیل انعکاس داد. در صورتی که چنین کاری قابل انجام نباشد (یعنی تغییرات کد را نتوان به سطوح انتزاع بالاتر گسترش داد)، عملا به تدریج با این مشکل رو به رو می‌شویم که مصنوعات مراحل اولیه پروژه از رده خارج می‌شوند و قابل استفاده نخواهند بود. 
		
موضوع دیگری که ارتباط نزدیکی با مفهوم \lr{Seamlessness} دارد موضوع \lr{Software Contracting} است. یکی از ویژگی‌های اصلی رویکرد شی‌گرا این است که هر مرحله از اجزا (\lr{Component}) قوی‌تری ساخته می‌شود که بر پایه و با استفاده از اجزای پیشین هستند. حال اگر این اجزا به مشکلی بخورند، کل سیستم ازهمدیگر می‌پاشد. در نتیجه آن مسئله \lr{Software Contracting} مطرح می‌شود. ایده اصلی این است که تضمین‌ها و \lr{Assertion} هایی وجود داشته باشد که معنای هر کلاس را مشخص کنند و مشخص کنند که هر متود دقیقا چه پیش‌شرط و پس‌شرط‌هایی دارد و عملا یک ناوردای کلاسی (\lr{Class Invariant}) خلق کنند.
		
		\item 
		ابتدا به این توجه کنید که در روش‌های سنتی نرم‌افزار، خیلی از کارها باید چندین بار و با \lr{Notation} های مختلف انجام بشوند. به عنوان مثال تحلیل نیازمندی به شکل رسمی به گونه‌ای انجام شده و پیاده‌سازی و برنامه‌نویسی نهایی هیچ شباهتی به آن نوشتارهای رسمی نندارد.  این موارد باعث ایجاد نوعی ناهمگونی می‌شوند که در نهایت، با هر تغییر نیاز به فرآیند طابق‌فرسایی برای انعکاس این تغییرات خواهیم داشت و در غیر این صورت به برنامه‌ای می‌رسیم که تحلیل، طراحی و در نهایت پیاده‌سازی آن هر کدام موارد متفاوتی را توصیف می‌کنند.
		
		در این میان، متودولوژی‌های توسعه و ایجاد بی‌درز وارد می‌شوند. در این فرآیند‌ها اصول یکسانی بر همه قسمت‌ها حاکم است. در روش‌های توسعه شی‌گرا و مبتنی بر \lr{Design by Contract }امکان توصیف سیستم با یک نمادگذاری واحد به کمک کلاس‌ها، وراثت، \lr{Contract} ها و همچنین مخفی‌سازی اطلاعات (\lr{Information Hiding} یا \lr{Encapsulation}) وجود دارد. چیزی که در این روش تغییر می‌کند صرفا سطح انتزاع است. در سطح تحلیل، تنها مسئله و محدودیت‌های خارجی توصیف می‌وشند، در سطح طراحی معماری راه‌حل توصیف شده و در مرحله پیاده‌سازی عملا نحوه کارکرد درونی این راه‌حل به نمایش در می‌آید. با این حال اگر یکسری تفاوت‌های ظاهری حذف بشوند، عملا \lr{Notation} اصلی و محیط توسعه (\lr{IDE}) یکسان است و ایده‌های تولیدی یکسانی در نظر گرفته می‌شوند. در متدولوژی‌های بی‌درز شاهد جابه‌جایی‌های پرهزینه بین ابزارها و نمادگذاری‌ها و مفاهیمی که باهمدیگر تناسب ندارند نیستیم. تمرکز اصلی بر مدل‌سازی قوی و پیاده‌سازی آن خواهد بود.
		
		نکته مهم این متدولوژی‌ها که در قسمت‌ قبلی هم گفته شد، برگشت‌پذیری است. بدین معنی که در هر لایه‌ای، از جمله نیازمندی، ایده طراحی، پیاده‌سازی، نکات مربوط به پرفرمنس و... که تغییری ایجاد بشود، با توجه به وجود زبان واحد بین قسمت‌ها این تغییر به راحتی به مراحل پایین‌تر یا بالاتر انتزاع قابل انتشار خواهد بود. تنها چیزی که در مهندسی نرم‌افزار ثابت است تغییر است. در متدولوژی‌های سنتی تغییر دشمن اصلی است ولی در متدولوژی‌های بی‌درز، تغییر یک رویداد رایج است که مشکلی در سیستم ایجاد نمی‌کند.
		
		
	
		\item
این موضوع تا حدی به نحوه پیاده‌سازی روش نیازمندی-رانه مدنظر دارد ولی در حالت کلی می‌توان تا حدی گفت که این طور نیست و این روش بی‌درز نیست. در روش نیازمندی-رانه تمرکز اصلی روی محصول نهایی است. در مقالل آن روش ویژگی‌رانه قرار دارد که هدف را دید کاربر نهایی قرار می‌دهد. در روش نیازمندی-رانه نیازمندی‌ها به شکل خیلی رسمی‌تری بیان می‌شوند ولی همین موضوع می‌تواند باعث بشود که انتشار تغییرات سخت باشد. در عوض آن روش‌های ویژگی-رانه که مبتنی بر دید کاربر نهایی هستند، راحت‌تر تغییر را می‌پذیرند. مثلا حالت زیر را در نظر بگیرید که برای ساخت یک خودروی کشاورزی توصیف شده است. در حالت نیازمندی‌رانه شامل چنین توصیفی هستیم:

\begin{enumerate}
	\item محصول چهار چرخ دارد.
	\item محصول باید بتواند با سرعت حداقل ۲۰ کیلومتر در ساعت حرکت کند.
	\item محصول باید بتواند انسان و بار را جا به جا کند.
\end{enumerate}


در عوض در حالت ویژگی‌رانه این خودرو به صورت زیر توصیف می‌شود:

«به عنوان یک اپراتور وسایل نقلیه، نیاز به وسیله‌ای دارم که بتواند انسان و بار را با حداقل سرعت ۲۰ کیلومتر بر ساعت روی زمین جا به جا کند تا بتوانم محصولات و کشاورزان را جا به جا کنم.»

در حالت اول شاهد یک توصیف خیلی رسمی هستیم و با وجود این که ممکن است خروجی کار این سه ویژگی را داشته باشد، اما همچنان باب میل کاربر نهایی نباشد. در حالت دوم که مبتنی بر ویژگی است، نظر نهایی این که کاربر به چه چیزی نیاز دارد بیان شده است. انتشار تغییرات  در این حالت راحت‌تر صورت می‌گیرد و هر چند در حالت اول می‌توانیم ترجمه اولیه نیازمندی به محصول را به راحتی انجام بدهیم، ولی \lr{Reversible} بودن که در بخش‌های گذشته گفته شد و انتشار تغییر به راحتی صورت نمی‌گیرد. در نتیجه می‌توان گفت که این روش \lr{Seamless} نیست. هر چند همچنان ممکن است روش‌های نیازمندی-رانه‌ای وجود داشته باشند که با تغییراتی \lr{Seamless} شده باشند.

		\item
به نظر می‌رسد که روش اسکرام را بتوان تا حد خوبی روشی بی‌درز دانست. مراحل روش اسکرام که در هر اسپرینت خلاصه شده‌اند، به هم متصل هستند و تمامی مراحل ساخت محصول الفبای مشترکی مبتنی بر ویژگی مدنظر کاربر دارند. در این متدولوژی شاهد این نیستیم که یک مدل تحلیل مثلا از طریق \lr{UML} با نمادگذاری‌های مختلف تولید بشود و سپس در مرحله تولید نرم افزار شاهد کدهایی کاملا متفاوت باشیم. بلکه در این روش همه چیز در خدمت این است که چه ارزشی تولید شده و به کاربر نهایی ارائه می‌شود و همه ابزارها در خدمت این الفبای تولید ارزش و نیازمندی کاربر نهایی هستند.

در نتیجه موضوعی که در بند قبل گفته شد، انتشار تغییر و منعکس کردن خواسته مشتری و ذی‌نفعان در محصول هم کار راحت‌‌تری خواهد بود. زیرا به جای استفاده از \lr{Notation} های مختلف و گیج‌کننده، هدف انتقال نیازمندی و خواست کاربر و تبدیل آن به محصول نهایی است و به راحتی امکان انجام این کار در هر اسپرینت بدون نیاز به تغییرات طاقت فرسا در مراحل مختلف کار وجود دارد.

	
	\end{enumerate}



\subsection*{مراجع}

\begin{latin}
	\begingroup
	\renewcommand{\section}[2]{}%
	
\begin{thebibliography}{9}
	
\bibitem{scrum}
Schwaber, K. and Sutherland, J., \textit{The scrum guide}. Scrum Alliance, 2011


\bibitem{seamless-book}
Walden, K. and Nerson, J.M.  \textit{Seamless object-oriented software architecture: analysis and design of reliable systems}. Prentice-Hall, 1995

‍‍\bibitem{es}
Eiffel Software,
\textit{Seamless development: focus on the essential}.
Accessed on 1/11/2023,
\url{https://www.eiffel.com/values/seamless-development/}


	
	
\end{thebibliography}
\endgroup
\end{latin}

}
