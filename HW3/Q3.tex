%نام و نام خانوادگی:
%شماره دانشجویی: 
\مسئله{}
SOLID
متشکل از پنج اصل طراحی برای ایجاد طراحی‌های مفهومی‌تر، منعطف‌تر \footnote{Flexible} و قابل نگهداری‌تر \footnote{Maintainable} است. GoF نیز شامل ۲۳ الگوی \footnote{Pattern} طراحی است که در سه دسته‌ی ایجادی \footnote{Creational}، ساختاری \footnote{Structural} و رفتاری \footnote{Behavioral} دسته‌بندی می‌شوند. 


\begin{enumerate}[a)]
	\item
هر یک از پنج اصل SOLID را در حدود دو خط توضیح دهید.
	\item
 منظور از هر یک از سه دسته‌ی ایجادی، ساختاری و رفتاری در GoF چیست؟
 	\item
تفاوت اصول SOLID با الگوهای طراحی GoF چیست؟
\end{enumerate}


\پاسخ{
\begin{enumerate}[a)]
	\item

\begin{enumerate}[a)]
	\item اصل اول (\lr{Single Responsibility}): \\
این اصل بیان می‌کند هر کلاس در کد باید تنها یک کار انجام دهد پس تنها یک دلیل برای تغییر آن باید وجود داشته باشد. اینطوری تعداد تست‌های بسیار کمتری برای هر کلاس نیاز است. علاوه بر آن هرچه کاربرد یک کلاس محدودتر باشد coupling کاهش می‌یابد. و در آخر باعث سردرگمی کمتر هنگامی که دنبال مقصود خاصی می‌گردیم می‌شود.
	\item اصل دوم (\lr{Open-Closed}): \\
در این اصل بیان می‌شود که هر کلاس باید برای پذیرای گسترش باشد اما نباید بازبینی و اصلاحی در آن صورت گیرد. این اصل برای جلوگیری از ایجاد باگ‌های جدید هنگامی که به کارایی‌ای که همین حالا هم داریم، دست می‌زنیم است. بدیهتا این اصل هنگامی که به اصلاح کدی که مشکل دارد می‌پردازیم مربوط نمی‌شود.
 	\item اصل سوم (\lr{Liskov Substitution}): \\
این اصل بیان می‌دارد اگر کلاس a زیرمجموعه‌ی کلاس b است، باید بتوانیم بدون اینکه خدشه‌ای به کارایی کد وارد شود جای b را با a عوض کنیم. به بیانی دیگر، می‌خواهیم شی‌های یک زیرکلاس، مانند شی‌های کلاس پدر خود رفتار کنند. این اصل کمک می‌کنند مدل سلسله‌مراتبی درستی از ارث‌بری داشته باشیم و از تولد باگ‌هایی که سال‌های سال در سیستم کشف نشده باقی می‌مانند ولی تاثیر منفی خود را روی سیستم می‌گذارند جلوگیری کنیم.
	\item اصل چهارم (\lr{Interface Segregation}): \\
اصل آخر بر این نکته اهتمام دارد که اینترفیس‌های بزرگتر باید به اینترفیس‌های کوچکتر تقسیم شوند. با اینکار هنگامی که یک کلاس را از روی یک اینترفیس می‌سازیم مطمئن هستیم تمامی کارایی‌هایی که صرفا به این کلاس مرتبط هستند را پیاده‌سازی می‌کنیم و از قرار دادن کاربرد‌های اضافه و بی‌ربط در آن کلاس خودداری می‌شود.
	\item اصل پنجم (\lr{Dependency Inversion}): \\
این اصل مربوط به جداسازی ماژول‌های نرم‌افزاری است. در این صورت، به جای ماژول‌های سطح بالای وابسته به ماژول‌های سطح پایین، هر دو به abstractها بستگی خواهند داشت. همچنین abstractionها نباید به جزئیات وابسته باشند، بلکه جزئیات باید به آن‌ها متکی باشند. این اصل برخلاف اسمش وابستگی‌ها را کاملا برعکس نمی‌کند بلکه مثلا در رابطه با وابستگی ماژول‌های سطح بالا به سطح پایینی‌ها، سطح وابستگی بین این دو را با موجودیتی به نام ابسترکت می‌شکند.
\end{enumerate}

	\item

\begin{enumerate}[a)]
	\item الگوی طراحی \lr{creational}: این الگو مکانیسم‌های مختلفی برای ساخت آبجکت‌ها ارائه می‌کند که انعطاف و قابلیت استفاده‌ی چندباره‌ی کد را بالا می‌برد. شامل ۵ الگوی طراحی با نام‌های singleton، factory، \lr{abstract factory}، ‌Builder و Prototype می‌شود.
	\item الگوی طراحی \lr{structural}: این الگو یک نقشه از چگونگی ترکیب آبجکت‌ها و کلاس‌‌های مختلف برای شکل دادن به ساختاری بزرگتر که برای اهداف بزرگتری چیده می‌شود است. این الگو نشان می‌دهد قطعه‌های منحصر به فرد در سیستم می‌توانند به صورت انعطاف‌پذیر و تعمیم‌پذیر با یکدیگر ترکیب شوند.
 	\item الگوی طراحی \lr{behavioral}: این الگو به تقسیم وظایف بین آبجکت‌ها و الگوریتم‌های مختلف می‌پردازد و در پی شناسایی الگوی ارتباطی مشترک بین آبجکت‌های مختلف شناسایی است. در چنین الگوهایی ارتباط بین آبجکت‌ها باید به گونه‌ای باشد که بتوانند به راحتی با یکدیگر صحبت کرده ولی در عین حال به صورت سست به هم متصل باشند (\lr{loosely coupled}).
\end{enumerate}

 	\item
فرق آن‌ها در این است که SOLID «اصول طراحی» \footnote{\lr{Design Principles}} هستند ولی GoF «الگوهای طراحی» \footnote{\lr{Design Patterns}} هستند. به همین منظور تفاوت بین اصول و الگوهای طراحی را بررسی می‌کنیم:

اصول طراحی مجموعه‌ای از قواعد انتزاعی هستند که ما باید در هنگام طراحی نرم‌افزار دنبال کنیم تا کیفیت آن را بالا ببریم. اصول طراحی درمورد پیاده‌سازی صحبتی نمی‌کنند؛ به همین دلیل برای هر زبان برنامه‌نویسی و هر پلتفرمی که شرایط مسئله را دارند قابل اجرا هستند. ما باید دلیل خیلی خوبی داشته‌باشیم که از اصول طراحی پیروی نکنیم.

الگوهای طراحی راه‌حل‌های قابل استفاده‌ی مجدد هستند که در شرایط مشخص می‌توان از آن‌ها برای مسئله‌های رایج در زمینه‌ی شی‌گرایی استفاده کرد. این راه‌حل‌های سطح پایین از طریق آزمون و خطا \footnote{Trial and Error} بدست آمده‌اند و ثابت شده‌است که درست کار می‌کنند. ما باید دلیل خیلی خوبی داشته‌باشیم که یک الگوی طراحی خاص را پیاده‌سازی کنیم.

بنابراین SOLID اصولی هستند که ما در اکثر مواقع و فارغ از زبان و پلتفرم باید آن‌ها را دنبال کنیم (مگر اینکه شرایط مسئله اجازه ندهند) و درمورد پیاده‌سازی صحبت نمی‌کنند. درمقابل GoF روش‌های پیاده‌سازی‌ و سطح پایینی هستند که تنها در سناریو‌ها و شرایط مشخصی می‌توانیم از آن‌ها استفاده کنیم.
\end{enumerate}
\subsection*{مراجع}

\begin{latin}
	\begingroup
	\renewcommand{\section}[2]{}%
	
\begin{thebibliography}{9}
%   Check this for adding items: https://www.student.unsw.edu.au/how-do-i-cite-electronic-sources
	\bibitem{Andrew Savetchuk's Blog}
	A. Savetchuk,
	\textit{The difference between Design Patterns and Design Principles},
	Accessed on 1/9/2023,
	\url{https://blog.savetchuk.com/the-difference-between-design-patterns-and-design-principles}
	
	
	\bibitem{StackExchange}
	\textit{Difference between Pattern and Principle},
	Accessed on 1/9/2023,
	\url{https://softwareengineering.stackexchange.com/questions/153586/difference-between-pattern-and-principle}

	\bibitem{StackExchange}
	\textit{What's the difference between design patterns and design principles?},
	Accessed on 1/9/2023,
	\url{https://stackoverflow.com/questions/31317141/whats-the-difference-between-design-patterns-and-design-principles}
\end{thebibliography}
\endgroup
\end{latin}

}
