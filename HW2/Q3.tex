%نام و نام خانوادگی:
%شماره دانشجویی: 
\مسئله{}
در فرآیند مهندسی نیازمندی ممکن است اشتباهات گوناگونی برای تیم‌های نرم‌افزاری رخ دهد. \lr{Buschmann} در یک تحقیق
(صفحه 162 کتاب \lr{Pressman} ویرایش 8) یک سری از اشتباهات رایج را مشخص کرده است.


\begin{enumerate}[a)]
	\item این اشتباهات را نام ببرید و شرح دهید.
	 
	 \item 
برای اجتناب از این اشتباهات رایج چه فعالیتها و یا چه تکنیکهای مهندسی نرمافزار را توصیه میکنید؟
\end{enumerate}


\پاسخ{

\begin{enumerate}[a)]
	\item
	در مقاله گفته شده، سه اشتباه رایج نام برده شده است \cite{pressman}:
	
	\begin{itemize}
		\item
		توجه بیش‌ از حد به ویژگی‌ها (\lr{Featuritis})
		
		\item 
		توجه بیش‌ از حد به انعطاف‌پذیری (\lr{Flexibilitis})
		
		\item 
		توجه بیش از حد به پرفورمنس (\lr{Performitis})
		
		
	\end{itemize}

پسوند \lr{itis} که در انتهای هر کدام از این کلمات آمده، پسوندی است که در پزشکی هم کاربرد زیادی دارد و به معنی التهاب است. در زمانی که بخواهند به زیاد بودن چیزی اشاره بشود هم پسوند \lr{itis} را می‌توان به انتهای واژه مربوط به آن افزود.

به ترتیب هر کدام را توضیح می‌دهیم.

\textbf{توجه بیش از حد به ویزگی‌ها}: 
این موضوع به معنی این است که سازندگان پوشش کارکردی را به کیفیت نرم‌افزار ترجیح بدهند. یعنی ترجیح بدهند که کارکردهای بیش‌تری از نرم‌افزار را پیده‌سازی کنند و در عوض ویژگی‌های کیفی نظیر اتکا‌پذیری، پرفرمنس، قابلیت نگه‌داشت و... به زمانی که «کارکردها به ثبات رسیده باشند» واگذار بشوند. بخشی از این رویکرد ناشی از تفکر ذی‌نفعان است که ممکن است در نگاه اول تعداد بیش‌تر ویژگی‌ها و کارکردها به دلیل ملموس‌تر بودن به کیفیت نرم‌افزاار ترجیح بدهند. بایان حال نرم‌افزاری که ویژگی‌های کیفی اجرایی را نداشته باشد، به احتمال زیادی حتی در صورت پیاده‌سازی کارکردهای زیادی، در آینده با مشکلات جدی رو به رو می‌شود \cite{buschmann}.


\textbf{توجه بیش‌ از حد به انعطاف پذیری}:
مورد دیگری که ممکن است پیش بیاید این است که معماران نرم‌افزار توجه زیادی به انعطاف‌پذیری نرم‌افزار خود داشته باشند و معماری آن را مبتنی بر اجزایی قرار بدهند که امکان وفق‌پذیری، تنظی ‌کردن و گسترش آن را به شکل بی‌رویه‌ای فراهم بکند. این موضوع در نهایت ممکن است باعث بشود سیستمی که بدست می‌اید، آنقدر قسمت‌های مختلف برای تنظیم کردن داشته باشد که عملا تنظیم‌ کردن آن کار بسیا پیچیده‌ای بشود و در نهایت بعد از تنظیم شدن نهایی هم با سیستمی رو به رو بشویم که ویژگی‌های کیفی دیگر نظیر امنیت یا پرفرمنس فدای انعطاف‌پذیری آن شده‌اند \cite{buschmann}.

دلیل انجام این کار می‌تواند نیازمندی‌هایی باشد که به شکل ابهام‌امیز یا با دامنه خیلی وسیعی تعریف شده‌اند و به دلیل واضح نبودن، معماران سعی کنند که نرم‌افزار را انعطاف‌پذیر بسازند تا همه حالات را پوشش بدهد. در اصل ریشه مشکل در این است که معماران از انعطا‌ف‌پذیری به عنوان پوششی برای عدم قطعیت استفاده می‌کنند و به جای تصمیم‌گیری درست در شرایط سخت، سعی می‌کنند آن را با قابلیت‌های انعطاف‌پذیری در آینده پوشش داده و این تصمیم‌گیری را به عقب بیندازند \cite{Henny} . بدین ترتیب سیستمی را ایجاد می‌کنند که به شکلی فزاینده انعطاف‌پذیر است تا در آینده هر تصمیمی را بتوان روی آن اعمال کرد \cite{buschmann}.



\textbf{توجه بیش‌ از حد به پرفرمنس}:
 توصیفی که از این حالت می‌شود به این صورت است: «هر بخش سیستم به شکل مستقیم تحت تاثیر تمهیدات محلی اخذ شده برای تنظیم پرفرمنس است. هیچ استراتژی جامعی برای پرقرمنس وجود نداشته یا این استراتژی جامع سایر ویژگی‌های کیفی سیستم نظیر قابلیت تست یا قابلیت نگه‌داشت را نادیده می‌گیرد \cite{Marquardt}.» 
 
 این مشکل می‌تواند به شدت خود را در کنار دو مشکل دیگر بروز بدهد. در صورتی که سیستمی به دو مشکل دیگر دچار بشود، احتمالا در اواخر کار که مسئله ویژگی‌های کیفی نظیر پرفرمنس مطرح می‌شود، با مشکلاتی رو به رو شده و در آن مرحله به دلیل مشکلات قبلی و معماری بد سیستم، مجبور خواهند بود که به شکلی فزاینده قسمت‌های مختلف را به صورت مستقل بهینه‌سازی بکنند و در نتیجه‌ این بهینه‌سازی‌های بی‌رویه که برای پوشاندن معماری نامناسب سیستم انجام شده است، ویژگی‌های کیفی دیگر نظیر قابلیت نگه‌داشت از بین برود \cite{buschmann}.

 
 \item
 
 موضوع بعدی که مطرح می‌شود، راه‌های مقابله با این مشکلات است.
 
 در مورد مشکل \lr{Featuritis}، مسئله‌ای که وجود دارد این است که گاهی اوقات مدیران محصول لیستی بلند و بالا از نیازمندی‌ها و \lr{Feature} ها را با ددلاین‌های سخت‌گیرانه به تولیدکنندگان نرم‌افزار می‌دهند. نقل‌قولی وجود دارد که هنگامی که از یکی از‌ آنان علت این موضوع پرسیده شده، جواب این بوده‌: «آنان نمی‌دانند که چه چیزهایی مهم است. در نتیجه من باید بیش‌ از آن‌چه که واقعا نیاز است را از آنان بخواهم تا نتیجه نهایی قابل قبول باشد \cite{buschmann}.» 
 
 در این جا با مشکل عدم اعتماد از سمت مدیرمحصول رو به رو هستیم. بنابراین یکی از راه‌های حل مشکل \textbf{اعتمادسازی} در تیم است. 
 
 موضوع دیگر این است که معماران نرم‌افزار باید سعی‌کنند که چرخه معیوب عدم‌اعتماد و عدم تفاهم را بشکنند. زمانی که خواسته‌های عجیبی مطرح می‌شود، این معماران نرم‌افزار باید اعتراض خود را اعالم کرده و مشخص کنند که چنین چیزهایی ضمن رعایت اصول کیفی در بازه زمانی مشخص شده ممکن نیست. در صورتی که اعتراضی از سمت آنان صورت نگیرد، عملا یعنی مسئولیت این کار را پذیرفته‌اند و در نتیجه برای رساندن قابلیت‌های خواسته شده به موعد مشخص شده، مجبور می‌شوند از کیفیت نرم‌افزار بکاهند.  در نتیجه، معماران باید \textbf{کیفیت نرم‌افزار} را به عنوان اصل اساسی کار خود قرار داده و با \textbf{صداقت} و مشخص کردن توانایی‌های واقعی تیم، جلوی ایجاد شرایطی که برای رساندن کار نیاز به کاهش کیفیت نرم‌افزار و دچار شدن به \lr{Featuritis} باشد را بگیرند و از این طریق در راستای \textbf{اعتمادسازی} هم قدم بردارند \cite{buschmann}.
 
 مسئله دیگر که در مورد \lr{Flexibilitis} مطرح می‌شود، این است که معماران نرم‌‌افزار از این موضوع برای فرار از عدم‌قطعیت‌ها استفاده می‌کنند. گاهی اوقات نیازمندی‌های یک نرم‌افزار به شکل خیلی گسترده و مبهم تعریف شده‌اند \cite{buschmann2}. برای حل این مشکل،‌ باید \textbf{توانایی ارتباطی} معماران افزایش پیدا کرده و سعی کنند همه چیز را به وضوح با ذی‌نفعان مشخص کنند. همچنین آن‌ها باید \textbf{اعتماد کافی} به آن‌ها برای گرفتن تصمیمات سخت در حوزه طراحی وجود داشته باشد. خیلی از اوقات معماران برای فرار از تصمیمات طراحی دشوار، سعی می‌کنند انعطاف‌پذیری سیستم را افزایش دهند. \cite{Henny} در این مرد معماران باید بدانند که سیستم آن‌ها قرار نیست برای «هر شرایطی آماده باشد». \textbf{نیازمندی‌های سیستم باید مشخص باشد} و سیستم مطابق آن طراحی بشود و نه این که به بهانه این که سیستم برای هر نوع تغییری انعطاف‌پذیر باشد، آن‌ را به شکل فزاینده‌ای پیچیده بکنیم.
 
 برای \textbf{Performitis} هم باید توجه کرد که پرفرمنس جزئی جداگانه از ویژگی‌های کیفی نرم‌افزار نیست که در نهایت بخواهیم مستقلا از طریق وصله‌های مختلف آن را بهبود ببخشیم. اجزای کیفی باید همگی در تمامی طول ساخت نرم‌افزار مورد توجه باشند و از همان ابتدا و طراحی معماری سیستم، این قسمت‌ هم باید مورد توجه باشد تا در مراحل نهایی مجبور به بهینه‌سازی‌های جزئی که در کیفیت و پرفرمنس نهایی هم تاثیرگذار نیستند،‌ نشویم. این مورد با رفع دو ایراد قبلی ذکر شده ارتباط تنگاتنگی دارد. \cite{buschmann}
 
 
 یک مورد دیگر هم که خوب است به عنوان توجه شود، این است که در ابتدای توسعه نرم‌افزار باید نیازمندی‌های مهم از لحاظ معماری (\lr{Architecturally Significant Requirement}) که هم از لحاظ نیازمندی‌ها و \lr{Feature} ها مهم‌تر هستند و هم از لحاظ ویژگی‌های کیفی چالش برانگیز‌تر هستند باید پیاده‌سازی شود \cite{Pohl,Weiss}. ضمن این که در هنگام پیاده‌سازی آنان، باید توجه بر این باشد که اصل ویژگی خاسته شده به درستی پیاده‌سازی شود و هدف فراهم کردن امکان گسترش‌پذیری و انعطاف‌پذیری نباشد. زیرا اگر سیستمی خواسته اصلی‌ای را که از آن انتظار می‌رود نتواند محقق کند، امکان گسترش هم نخواهد داشت \cite{Czarnecki}.
 
 
\end{enumerate}
	

\subsection*{مراجع}

\begin{latin}
	\begingroup
	\renewcommand{\section}[2]{}%
	
\begin{thebibliography}{9}
%   Check this for adding items: https://www.student.unsw.edu.au/how-do-i-cite-electronic-sources

	\bibitem{pressman}
	R. Pressman,   B. Maxim (2014).
	S\textit{oftware Engineering: A Practitioner’s Approach, 8th Ed. }.
	McGraw-Hill.

	
	
	\bibitem{buschmann}
	F. Buschmann, (2010), \textit{Learning from Failure, Part 2: Featuritis, Performitis, and Other Diseases}, Software, IEEE. 27. 10 - 11. 10.1109/MS.2010.14. 
	
	
	\bibitem{Henny}
	K. Henney, (2009), \textit{Use Uncertainty as a Driver}, 97 Things Every Software Architect Should Know, R. Monson-Haefel, ed., O’Reilly.
	
	\bibitem{Marquardt}
	K. Marquardt, (2003), \textit{Performitis}, Proc. 8th European Conf. Pattern Languages of Programs, Universitätsverlag Konstanz,

	\bibitem{buschmann2}
F. Buschmann, (2009), \textit{Learning from Failure, Part 1: Scoping and Requirements Woes}, Software, IEEE. 26. 68 - 69. 10.1109/MS.2009.179. 
	
	\bibitem{Pohl}
K. Pohl, G. Böckle, and F. van der Linden, (2005), \textit{Software Product Line Engineering: Foundations, Principles, and Techniques}, Springer.
	
	
	\bibitem{Weiss}
	D.M. Weiss and C.T.R. Lai, (1999), \textit{Software Product-Line Engineering: A Family-Based Software Development Process}, Addison-Wesley.
	
	\bibitem{Czarnecki}
	K. Czarnecki and U. Eisenecker, (2000), \textit{Generative Programming, Methods, Tools and Applications}, Addison-Wesley.

	 

	  

	 
	
	
\end{thebibliography}
\endgroup
\end{latin}

}
